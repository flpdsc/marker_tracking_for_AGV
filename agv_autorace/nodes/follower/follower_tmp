#!/usr/bin/env python
#-*- coding: utf-8 -*-

import rospy
from ar_track_alvar_msgs.msg import AlvarMarkers
from turtlesim.msg import Pose
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion
from math import degrees, radians, pi, cos, sin, asin, sqrt

MAX_LIN_SPEED = 0.22
MAX_ANG_SPEED = 2.84
LIN_SPD = MAX_LIN_SPEED * 0.5
ANG_SPD = MAX_ANG_SPEED * 0.2

OFFSET = 0.1        # 0.25
CAM_ARM = 0.048     
X_TOLERANCE = 0.02  
ROT_CONST = 0.9     
DIST_CONST = 10 / 7 # 3.4

LIM_NEAR = 0.1      # 0.14
LIM_ROT = 0.2       
LIM_TARGET_POINT = 0.3
LIM_GRAB_POINT = 0.22

class Followers:
    def __init__(self):
        self.mission_step = -1
        self.target_id = -1
        self.pub = rospy.Publisher('/cmd_vel', Twist, queue_size = 10)        

        self.distance = 0
        self.angle = 0

        self.z = 0
        self.center = 0

        self.tw = Twist()
        self.theta = 0

        self.tb3pose = Pose()
        self.org = Pose()

        self.relative_angle = 0
        self.min_range = 0

        self.is_center_aligned = False
        self.is_straight_end = False
        self.is_rotate_end = True
        self.is_moving = False
        self.is_1st_look = True
        self.is_1st_back = True
        
        self.is_lost = False
        self.is_find = False



    def markerTracking(self):
        rospy.Subscriber('/ar_pose_marker', AlvarMarkers, self.get_marker)
        rospy.Subscriber('/tb3pose', Pose, self.get_pose)
        rospy.Subscriber('/scan', LaserScan, self.check_tb)

    def workspace(self):
        rospy.Subscriber('/ar_pose_marker', AlvarMarkers, self.get_marker)
        rospy.Subscriber('/tb3pose', Pose, self.get_pose)
        rospy.Subscriber('/scan', LaserScan, self.check_tb)

    def rallyPoint(self):
        rospy.Subscriber('/ar_pose_marker', AlvarMarkers, self.get_marker)
        rospy.Subscriber('/tb3pose', Pose, self.get_pose)
        rospy.Subscriber('/scan', LaserScan, self.check_tb)

    def parking(self):
        pass


    def get_marker(self, msg):
        if len(msg.markers) > 0:
            for msg in msg.markers:
                if msg.id == self.target_id:
                    self.is_find = True
                    if self.is_center_aligned == False and self.is_moving == False:
                        self.move2marker(msg)                    
        else:
            if self.is_find == True:
                print("lost foward turtlebot")
                print(degrees(self.relative_angle))
                self.tw.linear.x = 0
                self.tw.angular.z = 0
                self.pub.publish(self.tw)
                if self.mission_step == 1:
                    if self.is_rotate_end == True and abs(degrees(self.relative_angle)) > 1: #####
                        self.is_rotate_end = False
                        self.rotate(self.relative_angle)   #####

            else:
                if self.mission_step == 3:
                    if self.is_1st_back == True:
                        self.is_1st_back = False
                        self.straight(-0.1)
                print("find target")
                self.tw.linear.x = 0
                self.tw.angular.z = ANG_SPD
                self.pub.publish(self.tw)
            
    def move2marker(self, msg):
        global DIST_CONST
        self.tw.angular.x = 0
        self.tw.angular.z = 0
        self.pub.publish(self.tw)        
        self.align_center(msg)

        #########
        if self.mission_step == 2 or self mission_step == 3:
            if self.is_1st_look == True:                
                self.is_1st_look = False
                DIST_CONST = 10 / 7

        if self.is_center_aligned == True:
            self.is_moving = True
            self.is_center_aligned = False            
            self.get_marker_info(msg)
 
            if self.z > LIM_ROT and abs(self.theta) > pi / 6:
                self.calculate_carrot_coordinate()
                self.rotate(self.angle)
                if self.is_rotate_end == True:
                    self.is_rotate_end == False                
                    self.straight(self.distance)
                    if self.is_straight_end == True:
                        self.is_straight_end = False
                        self.rotate(-(self.theta+self.angle))
                self.init_marker_info()
            else:
                self.straight2marker() 
            self.is_moving = False
                       
    def align_center(self, msg):
        print("align")
        center = msg.pose.pose.position.x
        if center > X_TOLERANCE:
            self.tw.angular.z = -ANG_SPD  ######
        elif center < -X_TOLERANCE:
            self.tw.angular.z = ANG_SPD     ######
        else:
            self.tw.angular.z = 0        
        self.pub.publish(self.tw)
        
        if self.tw.angular.z == 0:
            self.is_center_aligned = True
       
    def straight2marker(self):
        if self.mission_step == 1 or self.mission_step == 2:
            if self.center > X_TOLERANCE + 0.01:
                self.tw.angular.z = -ANG_SPD * 0.5
            elif self.center < -X_TOLERANCE - 0.01:
                self.tw.angular.z = ANG_SPD * 0.5
            else:
                self.tw.angular.z = 0

        if self.mission_step == 1:        
            if self.z > LIM_NEAR:
                self.tw.linear.x = 0.7 * self.z + 0.01      ########
            else:
                self.tw.linear.x = 0
        elif self.mission_step == 2:
            if self.z > LIM_NEAR:
                self.tw.linear.x = 0.1      ########
            else:
                if self.min_range < LIM_TARGET_POINT and self.min_range != 0:         
                    self.tw.linear.x = 0; self.pub.publish(self.tw)                
                    rospy.set_param('/follower/aligned', True)  ########
                    self.tw.linear.x = 0.05; self.pub.publish(self.tw)
                    while self.min_range > LIM_GRAB_POINT:    pass
                    print "=============== arrival ==============="
                elif self.min_range > LIM_TARGET_POINT or self.min_range == 0:               
                    print(round(self.min_range, 4))
                    self.tw.linear.x = 0.1
        elif self.mission_step == 3:
            if self.z > LIM_NEAR:
                self.tw.linear.x = 0.1      ########
            elif self.min_range < LIM_TARGET_POINT and self.min_range != 0:
                self.tw.linear.x = 0            

        self.pub.publish(self.tw)

    def calculate_carrot_coordinate(self):
        print("calculate")
        self.distance = sqrt(OFFSET**2 + (self.z+CAM_ARM)**2 - (2*OFFSET*(self.z+CAM_ARM)*cos(self.theta)))
        if self.theta > 0:
            self.angle = asin(OFFSET/self.distance*sin(abs(self.theta)))
        else:
            self.angle = -asin(OFFSET/self.distance*sin(abs(self.theta)))

    def get_marker_info(self, msg):
                
        q = (msg.pose.pose.orientation.x, msg.pose.pose.orientation.y,
             msg.pose.pose.orientation.z, msg.pose.pose.orientation.w)
                                            
        quart = euler_from_quaternion(q)
        self.theta = quart[1]                        # range from (-3.14, 3.14) 
        self.z = DIST_CONST * msg.pose.pose.position.z
        self.center = msg.pose.pose.position.x

    def init_marker_info(self):
        self.theta = 0
        self.z = 0
        self.center = 0        

    def get_pose(self, msg):
        self.tb3pose = msg
        
    def update_org(self):
        while self.tb3pose.x == 0.0 or self.tb3pose.y == 0.0: pass
        
        self.org = self.tb3pose

    def elapsed_dist(self):
        return sqrt(pow((self.tb3pose.x - self.org.x), 2) + pow((self.tb3pose.y - self.org.y), 2))

    def straight(self, distance):
        tw = Twist()
        self.update_org()
        print("\ndistance: {} cm".format(round(distance*100, 2)))
        print("start from (%s, %s)" %(round(self.org.x, 4), round(self.org.y, 4)))
        
        if distance >= 0:
            tw.linear.x = LIN_SPD
        else:
            tw.linear.x = -LIN_SPD

        self.pub.publish(tw)
        while self.elapsed_dist() < abs(distance):  pass
        
        tw.linear.x = 0;    self.pub.publish(tw)
        print("stop to (%s, %s)" %(round(self.tb3pose.x, 2), round(self.tb3pose.y, 2)))
        self.is_straight_end = True

    def elapsed_angle(self):
        return abs(self.tb3pose.theta - self.org.theta)

    def rotate(self, angle):
        print("rotate, {} deg".format(round(degrees(angle), 1)))
        tw = Twist()
        self.update_org()
        
        if angle >= 0:	# angle(+): rotate left(ccw)
            tw.angular.z =  ANG_SPD
        else:			# angle(-): rotate right(cw)
            tw.angular.z = -ANG_SPD
            
        self.pub.publish(tw)
        while self.elapsed_angle() < ROT_CONST * abs(angle):    pass

        tw.angular.z =  0;  self.pub.publish(tw)
        self.is_rotate_end = True

    def check_tb(self, msg):
        print("scan")
        angle = 0
        t1 = msg.ranges
        self.min_range = min(i for i in t1 if i > 0)
        min_index = t1.index(self.min_range)

        if min_index > 110 and min_index < 250:
            pass
        else:
            if min_index < 110:
                angle = min_index
            else:
                angle = min_index - 360

        self.relative_angle = radians(angle)    

    def check_target(self, msg):
        t1 = msg.ranges
        min_range = min(i for i in t1 if i > 0)
        min_index = t1.index(min_range)

        if 80 < min_index < 280:
            pass
        else:
            self.min_range = min_range

if __name__ == '__main__':
    try:
        rospy.init_node('follower', anonymous = True)

        # 파라미터를 통해 터틀봇 ID를 받음
        tb_id = rospy.get_param('/tb_id')

        #마커 트래킹
        mission1 = Followers()
        mission1.mission_step = 1
        if tb_id == 'tb2':
            mission1.target_id = 16
        elif tb_id == 'tb3':
            mission1.target_id = 10
        mission1.markerTracking()

        #미션 수행
        mission2 = Followers()
        mission2.mission_step = 2
        if tb_id == 'tb2':
            mission2.target_id = 7
        elif tb_id == 'tb3':
            mission2.target_id = 5
        mission2.workspace()

        #RP
        mission3 = Followers()
        mission3.mission_step = 3
        mission3.target_id = 6
        mission3.rallyPoint()

        #마커 트래킹
        mission1 = Followers()
        mission1.mission_step = 1
        if tb_id == 'tb2':
            mission1.target_id = 16
        elif tb_id == 'tb3':
            mission1.target_id = 10
        mission1.markerTracking()

        #주차
        mission4 = Followers()
        mission4.mission_step = 4
        if tb_id == 'tb2':
            mission4.target_id = 7
        elif tb_id == 'tb3':
            mission4.target_id = 5
        mission4.parking()

    except rospy.ROSInterruptException:  pass